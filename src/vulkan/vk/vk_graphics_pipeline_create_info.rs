// Generated by `scripts/generate.js`

use std::os::raw::c_char;
use std::ops::Deref;
use std::ptr;
use std::cmp;
use std::mem;
use utils::c_bindings::*;
use utils::vk_convert::*;
use utils::vk_null::*;
use utils::vk_ptr::*;
use utils::vk_traits::*;
use vulkan::vk::*;
use vulkan::vk::{VkStructureType,RawVkStructureType};
use vulkan::vk::{VkPipelineCreateFlags,RawVkPipelineCreateFlags};
use vulkan::vk::{VkPipelineShaderStageCreateInfo,RawVkPipelineShaderStageCreateInfo};
use vulkan::vk::{VkPipelineVertexInputStateCreateInfo,RawVkPipelineVertexInputStateCreateInfo};
use vulkan::vk::{VkPipelineInputAssemblyStateCreateInfo,RawVkPipelineInputAssemblyStateCreateInfo};
use vulkan::vk::{VkPipelineTessellationStateCreateInfo,RawVkPipelineTessellationStateCreateInfo};
use vulkan::vk::{VkPipelineViewportStateCreateInfo,RawVkPipelineViewportStateCreateInfo};
use vulkan::vk::{VkPipelineRasterizationStateCreateInfo,RawVkPipelineRasterizationStateCreateInfo};
use vulkan::vk::{VkPipelineMultisampleStateCreateInfo,RawVkPipelineMultisampleStateCreateInfo};
use vulkan::vk::{VkPipelineDepthStencilStateCreateInfo,RawVkPipelineDepthStencilStateCreateInfo};
use vulkan::vk::{VkPipelineColorBlendStateCreateInfo,RawVkPipelineColorBlendStateCreateInfo};
use vulkan::vk::{VkPipelineDynamicStateCreateInfo,RawVkPipelineDynamicStateCreateInfo};
use vulkan::vk::{VkPipelineLayout,RawVkPipelineLayout};
use vulkan::vk::{VkRenderPass,RawVkRenderPass};
use vulkan::vk::{VkPipeline,RawVkPipeline};

/// Wrapper for [VkGraphicsPipelineCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkGraphicsPipelineCreateInfo.html).
#[derive(Debug, Clone)]
pub struct VkGraphicsPipelineCreateInfo<'a, 'b> {
    pub flags: VkPipelineCreateFlags,
    pub stages: Vec<VkPipelineShaderStageCreateInfo<'a, 'b>>,
    pub vertex_input_state: Option<VkPipelineVertexInputStateCreateInfo>,
    pub input_assembly_state: Option<VkPipelineInputAssemblyStateCreateInfo>,
    pub tessellation_state: Option<VkPipelineTessellationStateCreateInfo>,
    pub viewport_state: Option<VkPipelineViewportStateCreateInfo>,
    pub rasterization_state: VkPipelineRasterizationStateCreateInfo,
    pub multisample_state: Option<VkPipelineMultisampleStateCreateInfo>,
    pub depth_stencil_state: Option<VkPipelineDepthStencilStateCreateInfo>,
    pub color_blend_state: Option<VkPipelineColorBlendStateCreateInfo>,
    pub dynamic_state: Option<VkPipelineDynamicStateCreateInfo>,
    pub layout: VkPipelineLayout,
    pub render_pass: VkRenderPass,
    pub subpass: usize,
    pub base_pipeline_handle: Option<VkPipeline>,
    pub base_pipeline_index: isize,
}

#[doc(hidden)]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RawVkGraphicsPipelineCreateInfo {
    pub s_type: RawVkStructureType,
    pub next: *mut c_void,
    pub flags: RawVkPipelineCreateFlags,
    pub stage_count: u32,
    pub stages: *mut RawVkPipelineShaderStageCreateInfo,
    pub vertex_input_state: *mut RawVkPipelineVertexInputStateCreateInfo,
    pub input_assembly_state: *mut RawVkPipelineInputAssemblyStateCreateInfo,
    pub tessellation_state: *mut RawVkPipelineTessellationStateCreateInfo,
    pub viewport_state: *mut RawVkPipelineViewportStateCreateInfo,
    pub rasterization_state: *mut RawVkPipelineRasterizationStateCreateInfo,
    pub multisample_state: *mut RawVkPipelineMultisampleStateCreateInfo,
    pub depth_stencil_state: *mut RawVkPipelineDepthStencilStateCreateInfo,
    pub color_blend_state: *mut RawVkPipelineColorBlendStateCreateInfo,
    pub dynamic_state: *mut RawVkPipelineDynamicStateCreateInfo,
    pub layout: RawVkPipelineLayout,
    pub render_pass: RawVkRenderPass,
    pub subpass: u32,
    pub base_pipeline_handle: RawVkPipeline,
    pub base_pipeline_index: i32,
}

impl<'a, 'b> VkWrappedType<RawVkGraphicsPipelineCreateInfo> for VkGraphicsPipelineCreateInfo<'a, 'b> {
    fn vk_to_raw(src: &VkGraphicsPipelineCreateInfo, dst: &mut RawVkGraphicsPipelineCreateInfo) {
        dst.s_type = vk_to_raw_value(&VkStructureType::GraphicsPipelineCreateInfo);
        dst.next = ptr::null_mut();
        dst.flags = vk_to_raw_value(&src.flags);
        dst.stage_count = src.stages.len() as u32;
        dst.stages = new_ptr_vk_array(&src.stages);
        dst.vertex_input_state = new_ptr_vk_value_checked(&src.vertex_input_state);
        dst.input_assembly_state = new_ptr_vk_value_checked(&src.input_assembly_state);
        dst.tessellation_state = new_ptr_vk_value_checked(&src.tessellation_state);
        dst.viewport_state = new_ptr_vk_value_checked(&src.viewport_state);
        dst.rasterization_state = new_ptr_vk_value(&src.rasterization_state);
        dst.multisample_state = new_ptr_vk_value_checked(&src.multisample_state);
        dst.depth_stencil_state = new_ptr_vk_value_checked(&src.depth_stencil_state);
        dst.color_blend_state = new_ptr_vk_value_checked(&src.color_blend_state);
        dst.dynamic_state = new_ptr_vk_value_checked(&src.dynamic_state);
        dst.layout = vk_to_raw_value(&src.layout);
        dst.render_pass = vk_to_raw_value(&src.render_pass);
        dst.subpass = vk_to_raw_value(&src.subpass);
        dst.base_pipeline_handle = vk_to_raw_value_checked(&src.base_pipeline_handle);
        dst.base_pipeline_index = vk_to_raw_value(&src.base_pipeline_index);
    }
}

impl<'a, 'b> VkRawType<VkGraphicsPipelineCreateInfo<'a, 'b>> for RawVkGraphicsPipelineCreateInfo {
    fn vk_to_wrapped(src: &RawVkGraphicsPipelineCreateInfo) -> VkGraphicsPipelineCreateInfo<'a, 'b> {
        VkGraphicsPipelineCreateInfo {
            flags: RawVkPipelineCreateFlags::vk_to_wrapped(&src.flags),
            stages: new_vk_array(src.stage_count, src.stages),
            vertex_input_state: new_vk_value_checked(src.vertex_input_state),
            input_assembly_state: new_vk_value_checked(src.input_assembly_state),
            tessellation_state: new_vk_value_checked(src.tessellation_state),
            viewport_state: new_vk_value_checked(src.viewport_state),
            rasterization_state: new_vk_value(src.rasterization_state),
            multisample_state: new_vk_value_checked(src.multisample_state),
            depth_stencil_state: new_vk_value_checked(src.depth_stencil_state),
            color_blend_state: new_vk_value_checked(src.color_blend_state),
            dynamic_state: new_vk_value_checked(src.dynamic_state),
            layout: RawVkPipelineLayout::vk_to_wrapped(&src.layout),
            render_pass: RawVkRenderPass::vk_to_wrapped(&src.render_pass),
            subpass: u32::vk_to_wrapped(&src.subpass),
            base_pipeline_handle: Some(RawVkPipeline::vk_to_wrapped(&src.base_pipeline_handle)),
            base_pipeline_index: i32::vk_to_wrapped(&src.base_pipeline_index),
        }
    }
}

impl Default for VkGraphicsPipelineCreateInfo<'static, 'static> {
    fn default() -> VkGraphicsPipelineCreateInfo<'static, 'static> {
        VkGraphicsPipelineCreateInfo {
            flags: Default::default(),
            stages: Vec::new(),
            vertex_input_state: None,
            input_assembly_state: None,
            tessellation_state: None,
            viewport_state: None,
            rasterization_state: Default::default(),
            multisample_state: None,
            depth_stencil_state: None,
            color_blend_state: None,
            dynamic_state: None,
            layout: Default::default(),
            render_pass: Default::default(),
            subpass: 0,
            base_pipeline_handle: None,
            base_pipeline_index: 0,
        }
    }
}

impl<'a, 'b> VkSetup for VkGraphicsPipelineCreateInfo<'a, 'b> {
    fn vk_setup(&mut self, fn_table: *mut VkFunctionTable) {
        VkSetup::vk_setup(&mut self.rasterization_state, fn_table);
        VkSetup::vk_setup(&mut self.layout, fn_table);
        VkSetup::vk_setup(&mut self.render_pass, fn_table);
    }
}

impl VkFree for RawVkGraphicsPipelineCreateInfo {
    fn vk_free(&self) {
        free_vk_ptr_array(self.stage_count as usize, self.stages);
        free_vk_ptr(self.vertex_input_state);
        free_vk_ptr(self.input_assembly_state);
        free_vk_ptr(self.tessellation_state);
        free_vk_ptr(self.viewport_state);
        free_vk_ptr(self.rasterization_state);
        free_vk_ptr(self.multisample_state);
        free_vk_ptr(self.depth_stencil_state);
        free_vk_ptr(self.color_blend_state);
        free_vk_ptr(self.dynamic_state);
    }
}
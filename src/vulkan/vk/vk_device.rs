// Generated by `scripts/generate.js`

use utils::c_bindings::*;
use utils::vk_traits::*;
use utils::vk_ptr::*;
use utils::vk_convert::*;
use std::os::raw::c_char;
use std::ops::Drop;
use std::ptr;
use std::mem;
use std::cmp;
use std::slice;
use vulkan::*;
use vulkan::vk::*;

#[doc(hidden)]
pub type RawVkDevice = u64;

/// Wrapper for [VkDevice](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkDevice.html).
#[derive(Debug, Clone, Copy)]
pub struct VkDevice {
    _handle: RawVkDevice,
    _fn_table: *mut VkFunctionTable
}

impl VkRawType<VkDevice> for RawVkDevice {
    fn vk_to_wrapped(src: &RawVkDevice) -> VkDevice {
        VkDevice {
            _handle: *src,
            _fn_table: ptr::null_mut()
        }
    }
}

impl VkWrappedType<RawVkDevice> for VkDevice {
    fn vk_to_raw(src: &VkDevice, dst: &mut RawVkDevice) {
        *dst = src._handle
    }
}

impl Default for VkDevice {
    fn default() -> VkDevice {
        VkDevice {
            _handle: 0,
            _fn_table: ptr::null_mut()
        }
    }
}

impl PartialEq for VkDevice {
    fn eq(&self, other: &VkDevice) -> bool {
        self._handle == other._handle
    }
}

impl VkSetup for VkDevice {
    fn vk_setup(&mut self, fn_table: *mut VkFunctionTable) {
        self._fn_table = fn_table;
    }
}

impl VkDevice {
    
    /// Returns the internal Vulkan handle for the object.
    pub fn vk_handle(&self) -> u64 {
        self._handle
    }
    
    /// Wrapper for [vkDestroyDevice](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkDestroyDevice.html).
    pub fn destroy(&self) {
        unsafe {
            ((&*self._fn_table).vkDestroyDevice)(self._handle, ptr::null());
            Box::from_raw(self._fn_table);
        }
    }
    
    /// Wrapper for [vkGetDeviceQueue](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetDeviceQueue.html).
    pub fn get_queue(&self, queue_family_index: usize, queue_index: usize) -> VkQueue {
        unsafe {
            let raw_queue_family_index = vk_to_raw_value(&queue_family_index);
            let raw_queue_index = vk_to_raw_value(&queue_index);
            let raw_queue = &mut mem::zeroed() as *mut RawVkQueue;
            
            ((&*self._fn_table).vkGetDeviceQueue)(self._handle, raw_queue_family_index, raw_queue_index, raw_queue);
            
            let mut queue = new_vk_value(raw_queue);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut queue, fn_table);
            queue
        }
    }
    
    /// Wrapper for [vkDeviceWaitIdle](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkDeviceWaitIdle.html).
    pub fn wait_idle(&self) -> Result<(), VkResult> {
        unsafe {
            let vk_result = ((&*self._fn_table).vkDeviceWaitIdle)(self._handle);
            if vk_result == 0 { Ok(()) } else { Err(RawVkResult::vk_to_wrapped(&vk_result)) }
        }
    }
    
    /// Wrapper for [vkAllocateMemory](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkAllocateMemory.html).
    pub fn allocate_memory(&self, allocate_info: VkMemoryAllocateInfo) -> Result<VkDeviceMemory, (VkResult, VkDeviceMemory)> {
        unsafe {
            let raw_allocate_info = new_ptr_vk_value(&allocate_info);
            let mut vk_result = 0;
            let raw_memory = &mut mem::zeroed() as *mut RawVkDeviceMemory;
            
            vk_result = ((&*self._fn_table).vkAllocateMemory)(self._handle, raw_allocate_info, ptr::null(), raw_memory);
            
            let mut memory = new_vk_value(raw_memory);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut memory, fn_table);
            }
            free_vk_ptr(raw_allocate_info);
            if vk_result == 0 { Ok(memory) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), memory)) }
        }
    }
    
    /// Wrapper for [vkFlushMappedMemoryRanges](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkFlushMappedMemoryRanges.html).
    pub fn flush_mapped_memory_ranges(&self, memory_ranges: Vec<VkMappedMemoryRange>) -> Result<(), VkResult> {
        unsafe {
            let raw_memory_range_count = memory_ranges.len() as u32;
            let raw_memory_ranges = new_ptr_vk_array(&memory_ranges);
            let vk_result = ((&*self._fn_table).vkFlushMappedMemoryRanges)(self._handle, raw_memory_range_count, raw_memory_ranges);
            free_vk_ptr_array(raw_memory_range_count as usize, raw_memory_ranges);
            if vk_result == 0 { Ok(()) } else { Err(RawVkResult::vk_to_wrapped(&vk_result)) }
        }
    }
    
    /// Wrapper for [vkInvalidateMappedMemoryRanges](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkInvalidateMappedMemoryRanges.html).
    pub fn invalidate_mapped_memory_ranges(&self, memory_ranges: Vec<VkMappedMemoryRange>) -> Result<(), VkResult> {
        unsafe {
            let raw_memory_range_count = memory_ranges.len() as u32;
            let raw_memory_ranges = new_ptr_vk_array(&memory_ranges);
            let vk_result = ((&*self._fn_table).vkInvalidateMappedMemoryRanges)(self._handle, raw_memory_range_count, raw_memory_ranges);
            free_vk_ptr_array(raw_memory_range_count as usize, raw_memory_ranges);
            if vk_result == 0 { Ok(()) } else { Err(RawVkResult::vk_to_wrapped(&vk_result)) }
        }
    }
    
    /// Wrapper for [vkBindImageMemory](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkBindImageMemory.html).
    pub fn bind_image_memory(&self, image: VkImage, memory: VkDeviceMemory, memory_offset: usize) -> Result<(), VkResult> {
        unsafe {
            let raw_image = vk_to_raw_value(&image);
            let raw_memory = vk_to_raw_value(&memory);
            let raw_memory_offset = vk_to_raw_value(&memory_offset);
            let vk_result = ((&*self._fn_table).vkBindImageMemory)(self._handle, raw_image, raw_memory, raw_memory_offset);
            if vk_result == 0 { Ok(()) } else { Err(RawVkResult::vk_to_wrapped(&vk_result)) }
        }
    }
    
    /// Wrapper for [vkGetImageMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetImageMemoryRequirements.html).
    pub fn get_image_memory_requirements(&self, image: VkImage) -> VkMemoryRequirements {
        unsafe {
            let raw_image = vk_to_raw_value(&image);
            let raw_memory_requirements = &mut mem::zeroed() as *mut RawVkMemoryRequirements;
            
            ((&*self._fn_table).vkGetImageMemoryRequirements)(self._handle, raw_image, raw_memory_requirements);
            
            let mut memory_requirements = new_vk_value(raw_memory_requirements);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut memory_requirements, fn_table);
            memory_requirements
        }
    }
    
    /// Wrapper for [vkGetImageSparseMemoryRequirements](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetImageSparseMemoryRequirements.html).
    pub fn get_image_sparse_memory_requirements(&self, image: VkImage) -> Vec<VkSparseImageMemoryRequirements> {
        unsafe {
            let raw_image = vk_to_raw_value(&image);
            let mut raw_sparse_memory_requirements : *mut RawVkSparseImageMemoryRequirements = ptr::null_mut();
            let raw_sparse_memory_requirement_count = &mut mem::zeroed() as *mut u32;
            ((&*self._fn_table).vkGetImageSparseMemoryRequirements)(self._handle, raw_image, raw_sparse_memory_requirement_count, raw_sparse_memory_requirements);
            raw_sparse_memory_requirements = calloc(*raw_sparse_memory_requirement_count as usize, mem::size_of::<RawVkSparseImageMemoryRequirements>()) as *mut RawVkSparseImageMemoryRequirements;
            
            ((&*self._fn_table).vkGetImageSparseMemoryRequirements)(self._handle, raw_image, raw_sparse_memory_requirement_count, raw_sparse_memory_requirements);
            
            let mut sparse_memory_requirements = new_vk_array_checked(*raw_sparse_memory_requirement_count, raw_sparse_memory_requirements).unwrap();
            for elt in &mut sparse_memory_requirements { VkSetup::vk_setup(elt, self._fn_table); }
            free(raw_sparse_memory_requirements as *mut u8);
            sparse_memory_requirements
        }
    }
    
    /// Wrapper for [vkCreateFence](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateFence.html).
    pub fn create_fence(&self, create_info: VkFenceCreateInfo) -> Result<VkFence, (VkResult, VkFence)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_fence = &mut mem::zeroed() as *mut RawVkFence;
            
            vk_result = ((&*self._fn_table).vkCreateFence)(self._handle, raw_create_info, ptr::null(), raw_fence);
            
            let mut fence = new_vk_value(raw_fence);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut fence, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(fence) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), fence)) }
        }
    }
    
    /// Wrapper for [vkResetFences](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkResetFences.html).
    pub fn reset_fences(&self, fences: Vec<VkFence>) -> Result<(), VkResult> {
        unsafe {
            let raw_fence_count = fences.len() as u32;
            let raw_fences = new_ptr_vk_array(&fences);
            let vk_result = ((&*self._fn_table).vkResetFences)(self._handle, raw_fence_count, raw_fences);
            free_ptr(raw_fences);
            if vk_result == 0 { Ok(()) } else { Err(RawVkResult::vk_to_wrapped(&vk_result)) }
        }
    }
    
    /// Wrapper for [vkWaitForFences](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkWaitForFences.html).
    pub fn wait_for_fences(&self, fences: Vec<VkFence>, wait_all: bool, timeout: u64) -> Result<(), VkResult> {
        unsafe {
            let raw_fence_count = fences.len() as u32;
            let raw_fences = new_ptr_vk_array(&fences);
            let raw_wait_all = vk_to_raw_value(&wait_all);
            let raw_timeout = timeout;
            let vk_result = ((&*self._fn_table).vkWaitForFences)(self._handle, raw_fence_count, raw_fences, raw_wait_all, raw_timeout);
            free_ptr(raw_fences);
            if vk_result == 0 { Ok(()) } else { Err(RawVkResult::vk_to_wrapped(&vk_result)) }
        }
    }
    
    /// Wrapper for [vkCreateSemaphore](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateSemaphore.html).
    pub fn create_semaphore(&self, create_info: VkSemaphoreCreateInfo) -> Result<VkSemaphore, (VkResult, VkSemaphore)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_semaphore = &mut mem::zeroed() as *mut RawVkSemaphore;
            
            vk_result = ((&*self._fn_table).vkCreateSemaphore)(self._handle, raw_create_info, ptr::null(), raw_semaphore);
            
            let mut semaphore = new_vk_value(raw_semaphore);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut semaphore, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(semaphore) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), semaphore)) }
        }
    }
    
    /// Wrapper for [vkCreateEvent](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateEvent.html).
    pub fn create_event(&self, create_info: VkEventCreateInfo) -> Result<VkEvent, (VkResult, VkEvent)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_event = &mut mem::zeroed() as *mut RawVkEvent;
            
            vk_result = ((&*self._fn_table).vkCreateEvent)(self._handle, raw_create_info, ptr::null(), raw_event);
            
            let mut event = new_vk_value(raw_event);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut event, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(event) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), event)) }
        }
    }
    
    /// Wrapper for [vkCreateQueryPool](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateQueryPool.html).
    pub fn create_query_pool(&self, create_info: VkQueryPoolCreateInfo) -> Result<VkQueryPool, (VkResult, VkQueryPool)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_query_pool = &mut mem::zeroed() as *mut RawVkQueryPool;
            
            vk_result = ((&*self._fn_table).vkCreateQueryPool)(self._handle, raw_create_info, ptr::null(), raw_query_pool);
            
            let mut query_pool = new_vk_value(raw_query_pool);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut query_pool, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(query_pool) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), query_pool)) }
        }
    }
    
    /// Wrapper for [vkCreateBuffer](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateBuffer.html).
    pub fn create_buffer(&self, create_info: VkBufferCreateInfo) -> Result<VkBuffer, (VkResult, VkBuffer)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_buffer = &mut mem::zeroed() as *mut RawVkBuffer;
            
            vk_result = ((&*self._fn_table).vkCreateBuffer)(self._handle, raw_create_info, ptr::null(), raw_buffer);
            
            let mut buffer = new_vk_value(raw_buffer);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut buffer, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(buffer) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), buffer)) }
        }
    }
    
    /// Wrapper for [vkCreateBufferView](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateBufferView.html).
    pub fn create_buffer_view(&self, create_info: VkBufferViewCreateInfo) -> Result<VkBufferView, (VkResult, VkBufferView)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_view = &mut mem::zeroed() as *mut RawVkBufferView;
            
            vk_result = ((&*self._fn_table).vkCreateBufferView)(self._handle, raw_create_info, ptr::null(), raw_view);
            
            let mut view = new_vk_value(raw_view);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut view, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(view) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), view)) }
        }
    }
    
    /// Wrapper for [vkCreateImage](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateImage.html).
    pub fn create_image(&self, create_info: VkImageCreateInfo) -> Result<VkImage, (VkResult, VkImage)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_image = &mut mem::zeroed() as *mut RawVkImage;
            
            vk_result = ((&*self._fn_table).vkCreateImage)(self._handle, raw_create_info, ptr::null(), raw_image);
            
            let mut image = new_vk_value(raw_image);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut image, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(image) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), image)) }
        }
    }
}
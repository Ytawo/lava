// Generated by `scripts/generate.js`

use utils::c_bindings::*;
use utils::vk_traits::*;
use utils::vk_ptr::*;
use utils::vk_convert::*;
use std::os::raw::c_char;
use std::ops::Drop;
use std::ptr;
use std::mem;
use std::cmp;
use std::slice;
use vulkan::*;
use vulkan::vk::*;

#[doc(hidden)]
pub type RawVkInstance = u64;

/// Wrapper for [VkInstance](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkInstance.html).
#[derive(Debug, Clone, Copy)]
pub struct VkInstance {
    _handle: RawVkInstance,
    _fn_table: *mut VkFunctionTable
}

impl VkRawType<VkInstance> for RawVkInstance {
    fn vk_to_wrapped(src: &RawVkInstance) -> VkInstance {
        VkInstance {
            _handle: *src,
            _fn_table: ptr::null_mut()
        }
    }
}

impl VkWrappedType<RawVkInstance> for VkInstance {
    fn vk_to_raw(src: &VkInstance, dst: &mut RawVkInstance) {
        *dst = src._handle
    }
}

impl Default for VkInstance {
    fn default() -> VkInstance {
        VkInstance {
            _handle: 0,
            _fn_table: ptr::null_mut()
        }
    }
}

impl PartialEq for VkInstance {
    fn eq(&self, other: &VkInstance) -> bool {
        self._handle == other._handle
    }
}

impl VkSetup for VkInstance {
    fn vk_setup(&mut self, fn_table: *mut VkFunctionTable) {
        self._fn_table = fn_table;
    }
}

impl VkInstance {
    pub fn create_surface<F : Fn(u64, *const c_void, *mut u64) -> i32>(&self, create_fn: F) -> Result<khr::VkSurface, VkResult> {
        unsafe {
            let raw_surface = &mut mem::uninitialized() as *mut khr::RawVkSurface;
            let vk_result = create_fn(self._handle, ptr::null(), raw_surface);
            if vk_result != 0 { return Err(RawVkResult::vk_to_wrapped(&vk_result)) }
            let mut surface = new_vk_value(raw_surface);
            VkSetup::vk_setup(&mut surface, self._fn_table);
            Ok(surface)
        }
    }
}

impl VkInstance {
    
    /// Returns the internal Vulkan handle for the object.
    pub fn vk_handle(&self) -> u64 {
        self._handle
    }
    
    /// Wrapper for [vkDestroyInstance](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkDestroyInstance.html).
    pub fn destroy(&self) {
        unsafe {
            ((&*self._fn_table).vkDestroyInstance)(self._handle, ptr::null());
            Box::from_raw(self._fn_table);
        }
    }
    
    /// Wrapper for [vkEnumeratePhysicalDevices](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumeratePhysicalDevices.html).
    pub fn enumerate_physical_devices(&self) -> Result<Vec<VkPhysicalDevice>, (VkResult, Vec<VkPhysicalDevice>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_physical_devices : *mut RawVkPhysicalDevice = ptr::null_mut();
            let raw_physical_device_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkEnumeratePhysicalDevices)(self._handle, raw_physical_device_count, raw_physical_devices);
            raw_physical_devices = calloc(*raw_physical_device_count as usize, mem::size_of::<RawVkPhysicalDevice>()) as *mut RawVkPhysicalDevice;
            
            vk_result = ((&*self._fn_table).vkEnumeratePhysicalDevices)(self._handle, raw_physical_device_count, raw_physical_devices);
            
            let mut physical_devices = new_vk_array_checked(*raw_physical_device_count, raw_physical_devices).unwrap();
            if vk_result == 0 {
                for elt in &mut physical_devices { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_physical_devices as *mut u8);
            if vk_result == 0 { Ok(physical_devices) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), physical_devices)) }
        }
    }
}
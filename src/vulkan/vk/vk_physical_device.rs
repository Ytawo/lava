// Generated by `scripts/generate.js`

use utils::c_bindings::*;
use utils::vk_traits::*;
use utils::vk_ptr::*;
use utils::vk_convert::*;
use std::os::raw::c_char;
use std::ops::Drop;
use std::ptr;
use std::mem;
use std::cmp;
use std::slice;
use vulkan::*;
use vulkan::vk::*;

#[doc(hidden)]
pub type RawVkPhysicalDevice = u64;

/// Wrapper for [VkPhysicalDevice](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkPhysicalDevice.html).
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevice {
    _handle: RawVkPhysicalDevice,
    _fn_table: *mut VkFunctionTable
}

impl VkRawType<VkPhysicalDevice> for RawVkPhysicalDevice {
    fn vk_to_wrapped(src: &RawVkPhysicalDevice) -> VkPhysicalDevice {
        VkPhysicalDevice {
            _handle: *src,
            _fn_table: ptr::null_mut()
        }
    }
}

impl VkWrappedType<RawVkPhysicalDevice> for VkPhysicalDevice {
    fn vk_to_raw(src: &VkPhysicalDevice, dst: &mut RawVkPhysicalDevice) {
        *dst = src._handle
    }
}

impl Default for VkPhysicalDevice {
    fn default() -> VkPhysicalDevice {
        VkPhysicalDevice {
            _handle: 0,
            _fn_table: ptr::null_mut()
        }
    }
}

impl PartialEq for VkPhysicalDevice {
    fn eq(&self, other: &VkPhysicalDevice) -> bool {
        self._handle == other._handle
    }
}

impl VkSetup for VkPhysicalDevice {
    fn vk_setup(&mut self, fn_table: *mut VkFunctionTable) {
        self._fn_table = fn_table;
    }
}

impl VkPhysicalDevice {
    
    /// Returns the internal Vulkan handle for the object.
    pub fn vk_handle(&self) -> u64 {
        self._handle
    }
    
    /// Wrapper for [vkGetPhysicalDeviceFeatures](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceFeatures.html).
    pub fn get_features(&self) -> VkPhysicalDeviceFeatures {
        unsafe {
            let raw_features = &mut mem::zeroed() as *mut RawVkPhysicalDeviceFeatures;
            
            ((&*self._fn_table).vkGetPhysicalDeviceFeatures)(self._handle, raw_features);
            
            let mut features = new_vk_value(raw_features);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut features, fn_table);
            features
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html).
    pub fn get_format_properties(&self, format: VkFormat) -> VkFormatProperties {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_format_properties = &mut mem::zeroed() as *mut RawVkFormatProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceFormatProperties)(self._handle, raw_format, raw_format_properties);
            
            let mut format_properties = new_vk_value(raw_format_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut format_properties, fn_table);
            format_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceImageFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html).
    pub fn get_image_format_properties(&self, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags) -> Result<VkImageFormatProperties, (VkResult, VkImageFormatProperties)> {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_type_ = vk_to_raw_value(&type_);
            let raw_tiling = vk_to_raw_value(&tiling);
            let raw_usage = vk_to_raw_value(&usage);
            let raw_flags = vk_to_raw_value(&flags);
            let mut vk_result = 0;
            let raw_image_format_properties = &mut mem::zeroed() as *mut RawVkImageFormatProperties;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceImageFormatProperties)(self._handle, raw_format, raw_type_, raw_tiling, raw_usage, raw_flags, raw_image_format_properties);
            
            let mut image_format_properties = new_vk_value(raw_image_format_properties);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut image_format_properties, fn_table);
            }
            if vk_result == 0 { Ok(image_format_properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), image_format_properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceProperties.html).
    pub fn get_properties(&self) -> VkPhysicalDeviceProperties {
        unsafe {
            let raw_properties = &mut mem::zeroed() as *mut RawVkPhysicalDeviceProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceProperties)(self._handle, raw_properties);
            
            let mut properties = new_vk_value(raw_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut properties, fn_table);
            properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceQueueFamilyProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html).
    pub fn get_queue_family_properties(&self) -> Vec<VkQueueFamilyProperties> {
        unsafe {
            let mut raw_queue_family_properties : *mut RawVkQueueFamilyProperties = ptr::null_mut();
            let raw_queue_family_property_count = &mut mem::zeroed() as *mut u32;
            ((&*self._fn_table).vkGetPhysicalDeviceQueueFamilyProperties)(self._handle, raw_queue_family_property_count, raw_queue_family_properties);
            raw_queue_family_properties = calloc(*raw_queue_family_property_count as usize, mem::size_of::<RawVkQueueFamilyProperties>()) as *mut RawVkQueueFamilyProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceQueueFamilyProperties)(self._handle, raw_queue_family_property_count, raw_queue_family_properties);
            
            let mut queue_family_properties = new_vk_array(*raw_queue_family_property_count, raw_queue_family_properties);
            for elt in &mut queue_family_properties { VkSetup::vk_setup(elt, self._fn_table); }
            free(raw_queue_family_properties as *mut u8);
            queue_family_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceMemoryProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html).
    pub fn get_memory_properties(&self) -> VkPhysicalDeviceMemoryProperties {
        unsafe {
            let raw_memory_properties = &mut mem::zeroed() as *mut RawVkPhysicalDeviceMemoryProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceMemoryProperties)(self._handle, raw_memory_properties);
            
            let mut memory_properties = new_vk_value(raw_memory_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut memory_properties, fn_table);
            memory_properties
        }
    }
    
    /// Wrapper for [vkCreateDevice](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateDevice.html).
    pub fn create_device(&self, create_info: VkDeviceCreateInfo) -> Result<VkDevice, (VkResult, VkDevice)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_device = &mut mem::zeroed() as *mut RawVkDevice;
            
            vk_result = ((&*self._fn_table).vkCreateDevice)(self._handle, raw_create_info, ptr::null(), raw_device);
            
            let mut device = new_vk_value(raw_device);
            if vk_result == 0 {
                let fn_table = Box::into_raw(Box::new(VkFunctionTable::from_device(*raw_device)));
                VkSetup::vk_setup(&mut device, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(device) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), device)) }
        }
    }
    
    /// Wrapper for [vkEnumerateDeviceExtensionProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumerateDeviceExtensionProperties.html).
    pub fn enumerate_device_extension_properties(&self, layer_name: Option<&str>) -> Result<Vec<VkExtensionProperties>, (VkResult, Vec<VkExtensionProperties>)> {
        unsafe {
            let raw_layer_name = new_ptr_string_checked(&layer_name);
            let mut vk_result = 0;
            let mut raw_properties : *mut RawVkExtensionProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkEnumerateDeviceExtensionProperties)(self._handle, raw_layer_name, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkExtensionProperties>()) as *mut RawVkExtensionProperties;
            
            vk_result = ((&*self._fn_table).vkEnumerateDeviceExtensionProperties)(self._handle, raw_layer_name, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free_ptr(raw_layer_name);
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkEnumerateDeviceLayerProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumerateDeviceLayerProperties.html).
    pub fn enumerate_device_layer_properties(&self) -> Result<Vec<VkLayerProperties>, (VkResult, Vec<VkLayerProperties>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_properties : *mut RawVkLayerProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkEnumerateDeviceLayerProperties)(self._handle, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkLayerProperties>()) as *mut RawVkLayerProperties;
            
            vk_result = ((&*self._fn_table).vkEnumerateDeviceLayerProperties)(self._handle, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSparseImageFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html).
    pub fn get_sparse_image_format_properties(&self, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlags, usage: VkImageUsageFlags, tiling: VkImageTiling) -> Vec<VkSparseImageFormatProperties> {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_type_ = vk_to_raw_value(&type_);
            let raw_samples = vk_to_raw_value(&samples);
            let raw_usage = vk_to_raw_value(&usage);
            let raw_tiling = vk_to_raw_value(&tiling);
            let mut raw_properties : *mut RawVkSparseImageFormatProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            ((&*self._fn_table).vkGetPhysicalDeviceSparseImageFormatProperties)(self._handle, raw_format, raw_type_, raw_samples, raw_usage, raw_tiling, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkSparseImageFormatProperties>()) as *mut RawVkSparseImageFormatProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceSparseImageFormatProperties)(self._handle, raw_format, raw_type_, raw_samples, raw_usage, raw_tiling, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            free(raw_properties as *mut u8);
            properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceFeatures2](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceFeatures2.html).
    pub fn get_features_2(&self) -> VkPhysicalDeviceFeatures2 {
        unsafe {
            let raw_features = &mut mem::zeroed() as *mut RawVkPhysicalDeviceFeatures2;
            
            ((&*self._fn_table).vkGetPhysicalDeviceFeatures2)(self._handle, raw_features);
            
            let mut features = new_vk_value(raw_features);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut features, fn_table);
            features
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceProperties2](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceProperties2.html).
    pub fn get_properties_2(&self) -> VkPhysicalDeviceProperties2 {
        unsafe {
            let raw_properties = &mut mem::zeroed() as *mut RawVkPhysicalDeviceProperties2;
            
            ((&*self._fn_table).vkGetPhysicalDeviceProperties2)(self._handle, raw_properties);
            
            let mut properties = new_vk_value(raw_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut properties, fn_table);
            properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceFormatProperties2](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceFormatProperties2.html).
    pub fn get_format_properties_2(&self, format: VkFormat) -> VkFormatProperties2 {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_format_properties = &mut mem::zeroed() as *mut RawVkFormatProperties2;
            
            ((&*self._fn_table).vkGetPhysicalDeviceFormatProperties2)(self._handle, raw_format, raw_format_properties);
            
            let mut format_properties = new_vk_value(raw_format_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut format_properties, fn_table);
            format_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceImageFormatProperties2](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties2.html).
    pub fn get_image_format_properties_2(&self, image_format_info: VkPhysicalDeviceImageFormatInfo2) -> Result<VkImageFormatProperties2, (VkResult, VkImageFormatProperties2)> {
        unsafe {
            let raw_image_format_info = new_ptr_vk_value(&image_format_info);
            let mut vk_result = 0;
            let raw_image_format_properties = &mut mem::zeroed() as *mut RawVkImageFormatProperties2;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceImageFormatProperties2)(self._handle, raw_image_format_info, raw_image_format_properties);
            
            let mut image_format_properties = new_vk_value(raw_image_format_properties);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut image_format_properties, fn_table);
            }
            free_vk_ptr(raw_image_format_info);
            if vk_result == 0 { Ok(image_format_properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), image_format_properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceQueueFamilyProperties2](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties2.html).
    pub fn get_queue_family_properties_2(&self) -> Vec<VkQueueFamilyProperties2> {
        unsafe {
            let mut raw_queue_family_properties : *mut RawVkQueueFamilyProperties2 = ptr::null_mut();
            let raw_queue_family_property_count = &mut mem::zeroed() as *mut u32;
            ((&*self._fn_table).vkGetPhysicalDeviceQueueFamilyProperties2)(self._handle, raw_queue_family_property_count, raw_queue_family_properties);
            raw_queue_family_properties = calloc(*raw_queue_family_property_count as usize, mem::size_of::<RawVkQueueFamilyProperties2>()) as *mut RawVkQueueFamilyProperties2;
            
            ((&*self._fn_table).vkGetPhysicalDeviceQueueFamilyProperties2)(self._handle, raw_queue_family_property_count, raw_queue_family_properties);
            
            let mut queue_family_properties = new_vk_array(*raw_queue_family_property_count, raw_queue_family_properties);
            for elt in &mut queue_family_properties { VkSetup::vk_setup(elt, self._fn_table); }
            free(raw_queue_family_properties as *mut u8);
            queue_family_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceMemoryProperties2](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceMemoryProperties2.html).
    pub fn get_memory_properties_2(&self) -> VkPhysicalDeviceMemoryProperties2 {
        unsafe {
            let raw_memory_properties = &mut mem::zeroed() as *mut RawVkPhysicalDeviceMemoryProperties2;
            
            ((&*self._fn_table).vkGetPhysicalDeviceMemoryProperties2)(self._handle, raw_memory_properties);
            
            let mut memory_properties = new_vk_value(raw_memory_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut memory_properties, fn_table);
            memory_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSparseImageFormatProperties2](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties2.html).
    pub fn get_sparse_image_format_properties_2(&self, format_info: VkPhysicalDeviceSparseImageFormatInfo2) -> Vec<VkSparseImageFormatProperties2> {
        unsafe {
            let raw_format_info = new_ptr_vk_value(&format_info);
            let mut raw_properties : *mut RawVkSparseImageFormatProperties2 = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            ((&*self._fn_table).vkGetPhysicalDeviceSparseImageFormatProperties2)(self._handle, raw_format_info, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkSparseImageFormatProperties2>()) as *mut RawVkSparseImageFormatProperties2;
            
            ((&*self._fn_table).vkGetPhysicalDeviceSparseImageFormatProperties2)(self._handle, raw_format_info, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            free_vk_ptr(raw_format_info);
            free(raw_properties as *mut u8);
            properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceExternalBufferProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceExternalBufferProperties.html).
    pub fn get_external_buffer_properties(&self, external_buffer_info: VkPhysicalDeviceExternalBufferInfo) -> VkExternalBufferProperties {
        unsafe {
            let raw_external_buffer_info = new_ptr_vk_value(&external_buffer_info);
            let raw_external_buffer_properties = &mut mem::zeroed() as *mut RawVkExternalBufferProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceExternalBufferProperties)(self._handle, raw_external_buffer_info, raw_external_buffer_properties);
            
            let mut external_buffer_properties = new_vk_value(raw_external_buffer_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut external_buffer_properties, fn_table);
            free_vk_ptr(raw_external_buffer_info);
            external_buffer_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceExternalFenceProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceExternalFenceProperties.html).
    pub fn get_external_fence_properties(&self, external_fence_info: VkPhysicalDeviceExternalFenceInfo) -> VkExternalFenceProperties {
        unsafe {
            let raw_external_fence_info = new_ptr_vk_value(&external_fence_info);
            let raw_external_fence_properties = &mut mem::zeroed() as *mut RawVkExternalFenceProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceExternalFenceProperties)(self._handle, raw_external_fence_info, raw_external_fence_properties);
            
            let mut external_fence_properties = new_vk_value(raw_external_fence_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut external_fence_properties, fn_table);
            free_vk_ptr(raw_external_fence_info);
            external_fence_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceExternalSemaphoreProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceExternalSemaphoreProperties.html).
    pub fn get_external_semaphore_properties(&self, external_semaphore_info: VkPhysicalDeviceExternalSemaphoreInfo) -> VkExternalSemaphoreProperties {
        unsafe {
            let raw_external_semaphore_info = new_ptr_vk_value(&external_semaphore_info);
            let raw_external_semaphore_properties = &mut mem::zeroed() as *mut RawVkExternalSemaphoreProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceExternalSemaphoreProperties)(self._handle, raw_external_semaphore_info, raw_external_semaphore_properties);
            
            let mut external_semaphore_properties = new_vk_value(raw_external_semaphore_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut external_semaphore_properties, fn_table);
            free_vk_ptr(raw_external_semaphore_info);
            external_semaphore_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSurfaceSupportKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSurfaceSupportKHR.html).
    pub fn get_surface_support(&self, queue_family_index: usize, surface: khr::VkSurface) -> Result<bool, (VkResult, bool)> {
        unsafe {
            let raw_queue_family_index = vk_to_raw_value(&queue_family_index);
            let raw_surface = vk_to_raw_value(&surface);
            let mut vk_result = 0;
            let raw_supported = &mut mem::zeroed() as *mut u32;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceSupportKHR)(self._handle, raw_queue_family_index, raw_surface, raw_supported);
            
            let supported = new_vk_value(raw_supported);
            if vk_result == 0 { Ok(supported) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), supported)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSurfaceCapabilitiesKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilitiesKHR.html).
    pub fn get_surface_capabilities(&self, surface: khr::VkSurface) -> Result<khr::VkSurfaceCapabilities, (VkResult, khr::VkSurfaceCapabilities)> {
        unsafe {
            let raw_surface = vk_to_raw_value(&surface);
            let mut vk_result = 0;
            let raw_surface_capabilities = &mut mem::zeroed() as *mut khr::RawVkSurfaceCapabilities;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceCapabilitiesKHR)(self._handle, raw_surface, raw_surface_capabilities);
            
            let mut surface_capabilities = new_vk_value(raw_surface_capabilities);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut surface_capabilities, fn_table);
            }
            if vk_result == 0 { Ok(surface_capabilities) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), surface_capabilities)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSurfaceFormatsKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSurfaceFormatsKHR.html).
    pub fn get_surface_formats(&self, surface: khr::VkSurface) -> Result<Vec<khr::VkSurfaceFormat>, (VkResult, Vec<khr::VkSurfaceFormat>)> {
        unsafe {
            let raw_surface = vk_to_raw_value(&surface);
            let mut vk_result = 0;
            let mut raw_surface_formats : *mut khr::RawVkSurfaceFormat = ptr::null_mut();
            let raw_surface_format_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceFormatsKHR)(self._handle, raw_surface, raw_surface_format_count, raw_surface_formats);
            raw_surface_formats = calloc(*raw_surface_format_count as usize, mem::size_of::<khr::RawVkSurfaceFormat>()) as *mut khr::RawVkSurfaceFormat;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceFormatsKHR)(self._handle, raw_surface, raw_surface_format_count, raw_surface_formats);
            
            let mut surface_formats = new_vk_array(*raw_surface_format_count, raw_surface_formats);
            if vk_result == 0 {
                for elt in &mut surface_formats { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_surface_formats as *mut u8);
            if vk_result == 0 { Ok(surface_formats) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), surface_formats)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSurfacePresentModesKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSurfacePresentModesKHR.html).
    pub fn get_surface_present_modes(&self, surface: khr::VkSurface) -> Result<Vec<khr::VkPresentMode>, (VkResult, Vec<khr::VkPresentMode>)> {
        unsafe {
            let raw_surface = vk_to_raw_value(&surface);
            let mut vk_result = 0;
            let mut raw_present_modes : *mut khr::RawVkPresentMode = ptr::null_mut();
            let raw_present_mode_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfacePresentModesKHR)(self._handle, raw_surface, raw_present_mode_count, raw_present_modes);
            raw_present_modes = calloc(*raw_present_mode_count as usize, mem::size_of::<khr::RawVkPresentMode>()) as *mut khr::RawVkPresentMode;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfacePresentModesKHR)(self._handle, raw_surface, raw_present_mode_count, raw_present_modes);
            
            let present_modes = new_vk_array(*raw_present_mode_count, raw_present_modes);
            free(raw_present_modes as *mut u8);
            if vk_result == 0 { Ok(present_modes) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), present_modes)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDevicePresentRectanglesKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDevicePresentRectanglesKHR.html).
    pub fn get_present_rectangles(&self, surface: khr::VkSurface) -> Result<Vec<VkRect2D>, (VkResult, Vec<VkRect2D>)> {
        unsafe {
            let raw_surface = vk_to_raw_value(&surface);
            let mut vk_result = 0;
            let mut raw_rects : *mut RawVkRect2D = ptr::null_mut();
            let raw_rect_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDevicePresentRectanglesKHR)(self._handle, raw_surface, raw_rect_count, raw_rects);
            raw_rects = calloc(*raw_rect_count as usize, mem::size_of::<RawVkRect2D>()) as *mut RawVkRect2D;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDevicePresentRectanglesKHR)(self._handle, raw_surface, raw_rect_count, raw_rects);
            
            let mut rects = new_vk_array(*raw_rect_count, raw_rects);
            if vk_result == 0 {
                for elt in &mut rects { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_rects as *mut u8);
            if vk_result == 0 { Ok(rects) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), rects)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceDisplayPropertiesKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceDisplayPropertiesKHR.html).
    pub fn get_display_properties(&self) -> Result<Vec<khr::VkDisplayProperties>, (VkResult, Vec<khr::VkDisplayProperties>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_properties : *mut khr::RawVkDisplayProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayPropertiesKHR)(self._handle, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<khr::RawVkDisplayProperties>()) as *mut khr::RawVkDisplayProperties;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayPropertiesKHR)(self._handle, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceDisplayPlanePropertiesKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceDisplayPlanePropertiesKHR.html).
    pub fn get_display_plane_properties(&self) -> Result<Vec<khr::VkDisplayPlaneProperties>, (VkResult, Vec<khr::VkDisplayPlaneProperties>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_properties : *mut khr::RawVkDisplayPlaneProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(self._handle, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<khr::RawVkDisplayPlaneProperties>()) as *mut khr::RawVkDisplayPlaneProperties;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayPlanePropertiesKHR)(self._handle, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkGetDisplayPlaneSupportedDisplaysKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetDisplayPlaneSupportedDisplaysKHR.html).
    pub fn get_display_plane_supported_displays(&self, plane_index: usize) -> Result<Vec<khr::VkDisplay>, (VkResult, Vec<khr::VkDisplay>)> {
        unsafe {
            let raw_plane_index = vk_to_raw_value(&plane_index);
            let mut vk_result = 0;
            let mut raw_displays : *mut khr::RawVkDisplay = ptr::null_mut();
            let raw_display_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetDisplayPlaneSupportedDisplaysKHR)(self._handle, raw_plane_index, raw_display_count, raw_displays);
            raw_displays = calloc(*raw_display_count as usize, mem::size_of::<khr::RawVkDisplay>()) as *mut khr::RawVkDisplay;
            
            vk_result = ((&*self._fn_table).vkGetDisplayPlaneSupportedDisplaysKHR)(self._handle, raw_plane_index, raw_display_count, raw_displays);
            
            let mut displays = new_vk_array(*raw_display_count, raw_displays);
            if vk_result == 0 {
                for elt in &mut displays { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_displays as *mut u8);
            if vk_result == 0 { Ok(displays) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), displays)) }
        }
    }
    
    /// Wrapper for [vkGetDisplayModePropertiesKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetDisplayModePropertiesKHR.html).
    pub fn get_display_mode_properties(&self, display: khr::VkDisplay) -> Result<Vec<khr::VkDisplayModeProperties>, (VkResult, Vec<khr::VkDisplayModeProperties>)> {
        unsafe {
            let raw_display = vk_to_raw_value(&display);
            let mut vk_result = 0;
            let mut raw_properties : *mut khr::RawVkDisplayModeProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetDisplayModePropertiesKHR)(self._handle, raw_display, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<khr::RawVkDisplayModeProperties>()) as *mut khr::RawVkDisplayModeProperties;
            
            vk_result = ((&*self._fn_table).vkGetDisplayModePropertiesKHR)(self._handle, raw_display, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkCreateDisplayModeKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateDisplayModeKHR.html).
    pub fn create_display_mode(&self, display: khr::VkDisplay, create_info: khr::VkDisplayModeCreateInfo) -> Result<khr::VkDisplayMode, (VkResult, khr::VkDisplayMode)> {
        unsafe {
            let raw_display = vk_to_raw_value(&display);
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_mode = &mut mem::zeroed() as *mut khr::RawVkDisplayMode;
            
            vk_result = ((&*self._fn_table).vkCreateDisplayModeKHR)(self._handle, raw_display, raw_create_info, ptr::null(), raw_mode);
            
            let mut mode = new_vk_value(raw_mode);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut mode, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(mode) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), mode)) }
        }
    }
    
    /// Wrapper for [vkGetDisplayPlaneCapabilitiesKHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetDisplayPlaneCapabilitiesKHR.html).
    pub fn get_display_plane_capabilities(&self, mode: khr::VkDisplayMode, plane_index: usize) -> Result<khr::VkDisplayPlaneCapabilities, (VkResult, khr::VkDisplayPlaneCapabilities)> {
        unsafe {
            let raw_mode = vk_to_raw_value(&mode);
            let raw_plane_index = vk_to_raw_value(&plane_index);
            let mut vk_result = 0;
            let raw_capabilities = &mut mem::zeroed() as *mut khr::RawVkDisplayPlaneCapabilities;
            
            vk_result = ((&*self._fn_table).vkGetDisplayPlaneCapabilitiesKHR)(self._handle, raw_mode, raw_plane_index, raw_capabilities);
            
            let mut capabilities = new_vk_value(raw_capabilities);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut capabilities, fn_table);
            }
            if vk_result == 0 { Ok(capabilities) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), capabilities)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSurfaceCapabilities2KHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2KHR.html).
    pub fn get_surface_capabilities_2(&self, surface_info: khr::VkPhysicalDeviceSurfaceInfo2) -> Result<khr::VkSurfaceCapabilities2, (VkResult, khr::VkSurfaceCapabilities2)> {
        unsafe {
            let raw_surface_info = new_ptr_vk_value(&surface_info);
            let mut vk_result = 0;
            let raw_surface_capabilities = &mut mem::zeroed() as *mut khr::RawVkSurfaceCapabilities2;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceCapabilities2KHR)(self._handle, raw_surface_info, raw_surface_capabilities);
            
            let mut surface_capabilities = new_vk_value(raw_surface_capabilities);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut surface_capabilities, fn_table);
            }
            free_vk_ptr(raw_surface_info);
            if vk_result == 0 { Ok(surface_capabilities) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), surface_capabilities)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSurfaceFormats2KHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSurfaceFormats2KHR.html).
    pub fn get_surface_formats_2(&self, surface_info: khr::VkPhysicalDeviceSurfaceInfo2) -> Result<Vec<khr::VkSurfaceFormat2>, (VkResult, Vec<khr::VkSurfaceFormat2>)> {
        unsafe {
            let raw_surface_info = new_ptr_vk_value(&surface_info);
            let mut vk_result = 0;
            let mut raw_surface_formats : *mut khr::RawVkSurfaceFormat2 = ptr::null_mut();
            let raw_surface_format_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceFormats2KHR)(self._handle, raw_surface_info, raw_surface_format_count, raw_surface_formats);
            raw_surface_formats = calloc(*raw_surface_format_count as usize, mem::size_of::<khr::RawVkSurfaceFormat2>()) as *mut khr::RawVkSurfaceFormat2;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceFormats2KHR)(self._handle, raw_surface_info, raw_surface_format_count, raw_surface_formats);
            
            let mut surface_formats = new_vk_array(*raw_surface_format_count, raw_surface_formats);
            if vk_result == 0 {
                for elt in &mut surface_formats { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free_vk_ptr(raw_surface_info);
            free(raw_surface_formats as *mut u8);
            if vk_result == 0 { Ok(surface_formats) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), surface_formats)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceDisplayProperties2KHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceDisplayProperties2KHR.html).
    pub fn get_display_properties_2(&self) -> Result<Vec<khr::VkDisplayProperties2>, (VkResult, Vec<khr::VkDisplayProperties2>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_properties : *mut khr::RawVkDisplayProperties2 = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayProperties2KHR)(self._handle, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<khr::RawVkDisplayProperties2>()) as *mut khr::RawVkDisplayProperties2;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayProperties2KHR)(self._handle, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceDisplayPlaneProperties2KHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceDisplayPlaneProperties2KHR.html).
    pub fn get_display_plane_properties_2(&self) -> Result<Vec<khr::VkDisplayPlaneProperties2>, (VkResult, Vec<khr::VkDisplayPlaneProperties2>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_properties : *mut khr::RawVkDisplayPlaneProperties2 = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayPlaneProperties2KHR)(self._handle, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<khr::RawVkDisplayPlaneProperties2>()) as *mut khr::RawVkDisplayPlaneProperties2;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceDisplayPlaneProperties2KHR)(self._handle, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkGetDisplayModeProperties2KHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetDisplayModeProperties2KHR.html).
    pub fn get_display_mode_properties_2(&self, display: khr::VkDisplay) -> Result<Vec<khr::VkDisplayModeProperties2>, (VkResult, Vec<khr::VkDisplayModeProperties2>)> {
        unsafe {
            let raw_display = vk_to_raw_value(&display);
            let mut vk_result = 0;
            let mut raw_properties : *mut khr::RawVkDisplayModeProperties2 = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetDisplayModeProperties2KHR)(self._handle, raw_display, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<khr::RawVkDisplayModeProperties2>()) as *mut khr::RawVkDisplayModeProperties2;
            
            vk_result = ((&*self._fn_table).vkGetDisplayModeProperties2KHR)(self._handle, raw_display, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array(*raw_property_count, raw_properties);
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkGetDisplayPlaneCapabilities2KHR](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetDisplayPlaneCapabilities2KHR.html).
    pub fn get_display_plane_capabilities_2(&self, display_plane_info: khr::VkDisplayPlaneInfo2) -> Result<khr::VkDisplayPlaneCapabilities2, (VkResult, khr::VkDisplayPlaneCapabilities2)> {
        unsafe {
            let raw_display_plane_info = new_ptr_vk_value(&display_plane_info);
            let mut vk_result = 0;
            let raw_capabilities = &mut mem::zeroed() as *mut khr::RawVkDisplayPlaneCapabilities2;
            
            vk_result = ((&*self._fn_table).vkGetDisplayPlaneCapabilities2KHR)(self._handle, raw_display_plane_info, raw_capabilities);
            
            let mut capabilities = new_vk_value(raw_capabilities);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut capabilities, fn_table);
            }
            free_vk_ptr(raw_display_plane_info);
            if vk_result == 0 { Ok(capabilities) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), capabilities)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceExternalImageFormatPropertiesNV](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceExternalImageFormatPropertiesNV.html).
    pub fn get_external_image_format_properties(&self, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags, external_handle_type: nv::VkExternalMemoryHandleTypeFlags) -> Result<nv::VkExternalImageFormatProperties, (VkResult, nv::VkExternalImageFormatProperties)> {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_type_ = vk_to_raw_value(&type_);
            let raw_tiling = vk_to_raw_value(&tiling);
            let raw_usage = vk_to_raw_value(&usage);
            let raw_flags = vk_to_raw_value(&flags);
            let raw_external_handle_type = vk_to_raw_value(&external_handle_type);
            let mut vk_result = 0;
            let raw_external_image_format_properties = &mut mem::zeroed() as *mut nv::RawVkExternalImageFormatProperties;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceExternalImageFormatPropertiesNV)(self._handle, raw_format, raw_type_, raw_tiling, raw_usage, raw_flags, raw_external_handle_type, raw_external_image_format_properties);
            
            let mut external_image_format_properties = new_vk_value(raw_external_image_format_properties);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut external_image_format_properties, fn_table);
            }
            if vk_result == 0 { Ok(external_image_format_properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), external_image_format_properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.html).
    pub fn get_generated_commands_properties(&self, features: nvx::VkDeviceGeneratedCommandsFeatures) -> nvx::VkDeviceGeneratedCommandsLimits {
        unsafe {
            let raw_features = new_ptr_vk_value(&features);
            let raw_limits = &mut mem::zeroed() as *mut nvx::RawVkDeviceGeneratedCommandsLimits;
            
            ((&*self._fn_table).vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX)(self._handle, raw_features, raw_limits);
            
            let mut limits = new_vk_value(raw_limits);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut limits, fn_table);
            free_vk_ptr(raw_features);
            limits
        }
    }
    
    /// Wrapper for [vkReleaseDisplayEXT](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkReleaseDisplayEXT.html).
    pub fn release_display(&self, display: khr::VkDisplay) -> Result<(), VkResult> {
        unsafe {
            let raw_display = vk_to_raw_value(&display);
            let vk_result = ((&*self._fn_table).vkReleaseDisplayEXT)(self._handle, raw_display);
            if vk_result == 0 { Ok(()) } else { Err(RawVkResult::vk_to_wrapped(&vk_result)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSurfaceCapabilities2EXT](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSurfaceCapabilities2EXT.html).
    pub fn get_surface_capabilities_2_ext(&self, surface: khr::VkSurface) -> Result<ext::VkSurfaceCapabilities2, (VkResult, ext::VkSurfaceCapabilities2)> {
        unsafe {
            let raw_surface = vk_to_raw_value(&surface);
            let mut vk_result = 0;
            let raw_surface_capabilities = &mut mem::zeroed() as *mut ext::RawVkSurfaceCapabilities2;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceSurfaceCapabilities2EXT)(self._handle, raw_surface, raw_surface_capabilities);
            
            let mut surface_capabilities = new_vk_value(raw_surface_capabilities);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut surface_capabilities, fn_table);
            }
            if vk_result == 0 { Ok(surface_capabilities) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), surface_capabilities)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceMultisamplePropertiesEXT](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceMultisamplePropertiesEXT.html).
    pub fn get_multisample_properties(&self, samples: VkSampleCountFlags) -> ext::VkMultisampleProperties {
        unsafe {
            let raw_samples = vk_to_raw_value(&samples);
            let raw_multisample_properties = &mut mem::zeroed() as *mut ext::RawVkMultisampleProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceMultisamplePropertiesEXT)(self._handle, raw_samples, raw_multisample_properties);
            
            let mut multisample_properties = new_vk_value(raw_multisample_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut multisample_properties, fn_table);
            multisample_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceCalibrateableTimeDomainsEXT](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.html).
    pub fn get_calibrateable_time_domains(&self) -> Result<Vec<ext::VkTimeDomain>, (VkResult, Vec<ext::VkTimeDomain>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_time_domains : *mut ext::RawVkTimeDomain = ptr::null_mut();
            let raw_time_domain_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)(self._handle, raw_time_domain_count, raw_time_domains);
            raw_time_domains = calloc(*raw_time_domain_count as usize, mem::size_of::<ext::RawVkTimeDomain>()) as *mut ext::RawVkTimeDomain;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)(self._handle, raw_time_domain_count, raw_time_domains);
            
            let time_domains = new_vk_array(*raw_time_domain_count, raw_time_domains);
            free(raw_time_domains as *mut u8);
            if vk_result == 0 { Ok(time_domains) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), time_domains)) }
        }
    }
}
// Generated by `scripts/generate.js`

use utils::c_bindings::*;
use utils::vk_traits::*;
use utils::vk_ptr::*;
use utils::vk_convert::*;
use std::os::raw::c_char;
use std::ops::Drop;
use std::ptr;
use std::mem;
use std::cmp;
use std::slice;
use vulkan::*;
use vulkan::vk::*;

#[doc(hidden)]
pub type RawVkPhysicalDevice = u64;

/// Wrapper for [VkPhysicalDevice](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/VkPhysicalDevice.html).
#[derive(Debug, Clone, Copy)]
pub struct VkPhysicalDevice {
    _handle: RawVkPhysicalDevice,
    _fn_table: *mut VkFunctionTable
}

impl VkRawType<VkPhysicalDevice> for RawVkPhysicalDevice {
    fn vk_to_wrapped(src: &RawVkPhysicalDevice) -> VkPhysicalDevice {
        VkPhysicalDevice {
            _handle: *src,
            _fn_table: ptr::null_mut()
        }
    }
}

impl VkWrappedType<RawVkPhysicalDevice> for VkPhysicalDevice {
    fn vk_to_raw(src: &VkPhysicalDevice, dst: &mut RawVkPhysicalDevice) {
        *dst = src._handle
    }
}

impl Default for VkPhysicalDevice {
    fn default() -> VkPhysicalDevice {
        VkPhysicalDevice {
            _handle: 0,
            _fn_table: ptr::null_mut()
        }
    }
}

impl PartialEq for VkPhysicalDevice {
    fn eq(&self, other: &VkPhysicalDevice) -> bool {
        self._handle == other._handle
    }
}

impl VkSetup for VkPhysicalDevice {
    fn vk_setup(&mut self, fn_table: *mut VkFunctionTable) {
        self._fn_table = fn_table;
    }
}

impl VkPhysicalDevice {
    
    /// Returns the internal Vulkan handle for the object.
    pub fn vk_handle(&self) -> u64 {
        self._handle
    }
    
    /// Wrapper for [vkGetPhysicalDeviceFeatures](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceFeatures.html).
    pub fn get_features(&self) -> VkPhysicalDeviceFeatures {
        unsafe {
            let raw_features = &mut mem::zeroed() as *mut RawVkPhysicalDeviceFeatures;
            
            ((&*self._fn_table).vkGetPhysicalDeviceFeatures)(self._handle, raw_features);
            
            let mut features = new_vk_value(raw_features);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut features, fn_table);
            features
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceFormatProperties.html).
    pub fn get_format_properties(&self, format: VkFormat) -> VkFormatProperties {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_format_properties = &mut mem::zeroed() as *mut RawVkFormatProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceFormatProperties)(self._handle, raw_format, raw_format_properties);
            
            let mut format_properties = new_vk_value(raw_format_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut format_properties, fn_table);
            format_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceImageFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceImageFormatProperties.html).
    pub fn get_image_format_properties(&self, format: VkFormat, type_: VkImageType, tiling: VkImageTiling, usage: VkImageUsageFlags, flags: VkImageCreateFlags) -> Result<VkImageFormatProperties, (VkResult, VkImageFormatProperties)> {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_type_ = vk_to_raw_value(&type_);
            let raw_tiling = vk_to_raw_value(&tiling);
            let raw_usage = vk_to_raw_value(&usage);
            let raw_flags = vk_to_raw_value(&flags);
            let mut vk_result = 0;
            let raw_image_format_properties = &mut mem::zeroed() as *mut RawVkImageFormatProperties;
            
            vk_result = ((&*self._fn_table).vkGetPhysicalDeviceImageFormatProperties)(self._handle, raw_format, raw_type_, raw_tiling, raw_usage, raw_flags, raw_image_format_properties);
            
            let mut image_format_properties = new_vk_value(raw_image_format_properties);
            if vk_result == 0 {
                let fn_table = self._fn_table;
                VkSetup::vk_setup(&mut image_format_properties, fn_table);
            }
            if vk_result == 0 { Ok(image_format_properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), image_format_properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceProperties.html).
    pub fn get_properties(&self) -> VkPhysicalDeviceProperties {
        unsafe {
            let raw_properties = &mut mem::zeroed() as *mut RawVkPhysicalDeviceProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceProperties)(self._handle, raw_properties);
            
            let mut properties = new_vk_value(raw_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut properties, fn_table);
            properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceQueueFamilyProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html).
    pub fn get_queue_family_properties(&self) -> Vec<VkQueueFamilyProperties> {
        unsafe {
            let mut raw_queue_family_properties : *mut RawVkQueueFamilyProperties = ptr::null_mut();
            let raw_queue_family_property_count = &mut mem::zeroed() as *mut u32;
            ((&*self._fn_table).vkGetPhysicalDeviceQueueFamilyProperties)(self._handle, raw_queue_family_property_count, raw_queue_family_properties);
            raw_queue_family_properties = calloc(*raw_queue_family_property_count as usize, mem::size_of::<RawVkQueueFamilyProperties>()) as *mut RawVkQueueFamilyProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceQueueFamilyProperties)(self._handle, raw_queue_family_property_count, raw_queue_family_properties);
            
            let mut queue_family_properties = new_vk_array_checked(*raw_queue_family_property_count, raw_queue_family_properties).unwrap();
            for elt in &mut queue_family_properties { VkSetup::vk_setup(elt, self._fn_table); }
            free(raw_queue_family_properties as *mut u8);
            queue_family_properties
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceMemoryProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceMemoryProperties.html).
    pub fn get_memory_properties(&self) -> VkPhysicalDeviceMemoryProperties {
        unsafe {
            let raw_memory_properties = &mut mem::zeroed() as *mut RawVkPhysicalDeviceMemoryProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceMemoryProperties)(self._handle, raw_memory_properties);
            
            let mut memory_properties = new_vk_value(raw_memory_properties);
            let fn_table = self._fn_table;
            VkSetup::vk_setup(&mut memory_properties, fn_table);
            memory_properties
        }
    }
    
    /// Wrapper for [vkCreateDevice](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkCreateDevice.html).
    pub fn create_device(&self, create_info: VkDeviceCreateInfo) -> Result<VkDevice, (VkResult, VkDevice)> {
        unsafe {
            let raw_create_info = new_ptr_vk_value(&create_info);
            let mut vk_result = 0;
            let raw_device = &mut mem::zeroed() as *mut RawVkDevice;
            
            vk_result = ((&*self._fn_table).vkCreateDevice)(self._handle, raw_create_info, ptr::null(), raw_device);
            
            let mut device = new_vk_value(raw_device);
            if vk_result == 0 {
                let fn_table = Box::into_raw(Box::new(VkFunctionTable::from_device(*raw_device)));
                VkSetup::vk_setup(&mut device, fn_table);
            }
            free_vk_ptr(raw_create_info);
            if vk_result == 0 { Ok(device) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), device)) }
        }
    }
    
    /// Wrapper for [vkEnumerateDeviceExtensionProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumerateDeviceExtensionProperties.html).
    pub fn enumerate_device_extension_properties(&self, layer_name: Option<String>) -> Result<Vec<VkExtensionProperties>, (VkResult, Vec<VkExtensionProperties>)> {
        unsafe {
            let raw_layer_name = new_ptr_string_checked(&layer_name);
            let mut vk_result = 0;
            let mut raw_properties : *mut RawVkExtensionProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkEnumerateDeviceExtensionProperties)(self._handle, raw_layer_name, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkExtensionProperties>()) as *mut RawVkExtensionProperties;
            
            vk_result = ((&*self._fn_table).vkEnumerateDeviceExtensionProperties)(self._handle, raw_layer_name, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array_checked(*raw_property_count, raw_properties).unwrap();
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free_ptr(raw_layer_name);
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkEnumerateDeviceLayerProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkEnumerateDeviceLayerProperties.html).
    pub fn enumerate_device_layer_properties(&self) -> Result<Vec<VkLayerProperties>, (VkResult, Vec<VkLayerProperties>)> {
        unsafe {
            let mut vk_result = 0;
            let mut raw_properties : *mut RawVkLayerProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            vk_result = ((&*self._fn_table).vkEnumerateDeviceLayerProperties)(self._handle, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkLayerProperties>()) as *mut RawVkLayerProperties;
            
            vk_result = ((&*self._fn_table).vkEnumerateDeviceLayerProperties)(self._handle, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array_checked(*raw_property_count, raw_properties).unwrap();
            if vk_result == 0 {
                for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            }
            free(raw_properties as *mut u8);
            if vk_result == 0 { Ok(properties) } else { Err((RawVkResult::vk_to_wrapped(&vk_result), properties)) }
        }
    }
    
    /// Wrapper for [vkGetPhysicalDeviceSparseImageFormatProperties](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkGetPhysicalDeviceSparseImageFormatProperties.html).
    pub fn get_sparse_image_format_properties(&self, format: VkFormat, type_: VkImageType, samples: VkSampleCountFlags, usage: VkImageUsageFlags, tiling: VkImageTiling) -> Vec<VkSparseImageFormatProperties> {
        unsafe {
            let raw_format = vk_to_raw_value(&format);
            let raw_type_ = vk_to_raw_value(&type_);
            let raw_samples = vk_to_raw_value(&samples);
            let raw_usage = vk_to_raw_value(&usage);
            let raw_tiling = vk_to_raw_value(&tiling);
            let mut raw_properties : *mut RawVkSparseImageFormatProperties = ptr::null_mut();
            let raw_property_count = &mut mem::zeroed() as *mut u32;
            ((&*self._fn_table).vkGetPhysicalDeviceSparseImageFormatProperties)(self._handle, raw_format, raw_type_, raw_samples, raw_usage, raw_tiling, raw_property_count, raw_properties);
            raw_properties = calloc(*raw_property_count as usize, mem::size_of::<RawVkSparseImageFormatProperties>()) as *mut RawVkSparseImageFormatProperties;
            
            ((&*self._fn_table).vkGetPhysicalDeviceSparseImageFormatProperties)(self._handle, raw_format, raw_type_, raw_samples, raw_usage, raw_tiling, raw_property_count, raw_properties);
            
            let mut properties = new_vk_array_checked(*raw_property_count, raw_properties).unwrap();
            for elt in &mut properties { VkSetup::vk_setup(elt, self._fn_table); }
            free(raw_properties as *mut u8);
            properties
        }
    }
}